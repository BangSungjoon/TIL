# Tree 2

## BST(Binary Search Tree) 자료구조

- Data들을 빠르게 검색할 수 있도록 체계적으로 저장을 해두고, 최대 O($log n$)의 빠른 속도로 값을 검색할 수 있는 자료 구조
- 빠르게 검색될 수 있도록, 특정 규칙을 갖는 이진 트리 형태로 값을 저장해둔다.

### 리스트 vs BST

- BST는 리스트 보다 더 빠른 삽입 / 삭제 / 탐색이 가능하다
- 리스트 성능
    - 삽입 : O(n), 단 맨 끝 삽입은 O(1)
    - 삭제 : O(n), 단 맨 끝 삭제는 O(1)
    - 탐색 : O(n)
- BST 성능
    - 삽입 : 평균 $O(logN)$
    - 삭제 : 평균 $O(logN)$
    - 탐색 : 평균 $O(logN)$
    
    <aside>
    💡 파이썬 공식 Library에는
    Binary Search Tree 자료구조가 내장되어 있지 않아 직접 구현해서 사용해야 한다.
    
    </aside>
    

### set 동작 원리 - 삽입 1

- insert(3) 수행 시 내부 동작
    - 처음 등장하는 값은, root에 저장된다.
- 부모 노드보다 작으면 왼쪽, 크면 오른쪽
    - 시간 복잡도는 logN

### BST 삽입 시간복잡도 : O(logN)

- 삽입을 위해, root부터 바닥 노드까지 탐색을 하며 자기 위치를 찾는다.
- 이는 트리의 높이(h)만큼 탐색 시간이 걸린다.
- $2^h-1$ = 노드의 수(N)
→ $log_2N$ = h
    
    <aside>
    💡 완벽하게 균형 잡힌 이진트리인 경우, 삽입 시간복잡도는 O(logN)이다.
    
    </aside>
    
    <aside>
    💡 BST는 반드시 완전 이진 트리 인 건 아니다!
    
    </aside>
    

### BST 동작 원리 - 순회

BST에서 DFS 중위순회를 하게 되면 Key 값이 작은 순서대로 탐색이 가능하다.

### 이진 탐색 트리 - 성능

- 탐색(searching), 삽입(insertion), 삭제(deletion) 시간은 트리의 높이 만큼 시간이 걸린다.
    - O(h), h : BST의 깊이(height)
- 평균의 경우
    - 이진 트리가 균형적으로 생성되어 있는 경우
    - O(log n)
- 최악의 경우
    - 한쪽으로 치우친 경사 이진 트리의 경우
    - O(n)
    - 순차 탐색과 시간복잡도가 같다.

### 이진 탐색 트리 - 연산 연습

<aside>
💡 BST 규칙을 유지해야 한다!

</aside>

- 삭제 연산
    - 시간복잡도 logN → 탐색을 해야 하기 때문에!
    - 리프 노드의 경우 : 그냥 삭제하면 됨!
    - 자식이 하나 있는 경우 : 자식을 부모와 연결 해준 뒤 삭제
    - 자식이 두 개 있는 경우 : 아래 둘 중 하나로 복사하여 대체한다.
        - 삭제하고자 하는 노드의 왼쪽 서브 트리의 가장 큰 값
        - 삭제하고자 하는 노드의 오른쪽 서브 트리의 가장 작은 값
        - 선택한 노드는 복사 이후 삭제!

### [정리] 이진 탐색 트리

- 탐색 작업을 효율적으로 하기 위한 자료구조
- 모든 원소는 서로 다른 유일한 키를 갖는다.
- key(왼쪽 서브 트리) < key(루트 노드) < key(오른쪽 서브 트리)
- 왼쪽 서브 트리와 오른쪽 서브 트리도 이진 탐색 트리다.
- 중위 순회하면 오름차순으로 정렬된 값을 얻을 수 있다.

---

## 힙 (Heap)

- 완전 이진 트리에 있는 노드 중에서 키 값이 가장 큰 노드나 키 값이 가장 작은 노드를 찾기 위해서 만든 자료구조
- 힙의 키를 우선순위로 활용하여 우선순위 큐를 구현할 수 있다.
- 최대 힙(max heap)
    - 키 값이 가장 큰 노드를 찾기 위한 완전 이진 트리
    - {부모 노드의 키 값 > 자식 노드의 키 값}
    - 루트 노드 : 키 값이 가장 큰 노드
- 최소 힙(min heap)
    - 키 값이 가장 작은 노드를 찾기 위한 완전 이진 트리
    - {부모 노드의 키 값 < 자식 노드의 키 값}
    - 루트 노드 : 키 값이 가장 작은 노드

### 힙 연산 - 삽입

1. 일단 맨 뒤에 삽입
2. 내 위치를 찾아감 (비교 → swap)
- 힙에서는 루트 노드의 원소 만을 삭제 할 수 있다.
- 루트 노드의 원소를 삭제하여 반환한다.
- 힙의 종류에 따라 최대 값 또는 최소 값을 구할 수 있다.
- 시간 복잡도는 $logN$ → 높이만큼 비교하니깐!

### 힙 연산 - 삭제

- 루트의 원소 삭제
    1. 루트 노드의 원소 삭제
    2. 마지막 노드 삭제
    3. 내 위치를 찾아감 ex. (삽입 노드 10 < 자식 노드 19) : 자리 바꾸기
        - 19 → 두 자식 노드 중 가장 큰 값
    4. 자리 확정
- 시간 복잡도는 $logN$ → 높이만큼 비교하니깐!
# Start2

## 비트 연산

### 비트와 바이트

- 1 bit : 0과 1을 표현하는 정보의 단위
- 1 Byte : 8 bit를 묶어 1 Byte라고 한다.

### 비트 연산

- 컴퓨터의 CPU는 0과 1로 다루어 동작 되며, 내부적으로 비트 연산을 사용하여 덧셈, 뺄셈, 곱셈 등을 계산한다.

### 비트 연산 챕터의 목적

- 사람이 사용하는 사칙 연산 (+, *, /, -)이 아닌 컴퓨터가 사용하는 연산인 “비트 연산”을 이해해본다.
- 더 나아가, 프로그래밍에서 비트 연산을 활용한 코딩 방법을 익혀본다.

### AND와 OR 비트 연산자 이해하기

- a AND b : a, b 둘 다 1일 때만 결과가 1이다. 그 외에는 0
- a OR b : a, b 둘 중 하나만 1이면 결과가 1이다. 그 외에는 0
    
    
    | 연산자 | 연산자의 기능 |
    | --- | --- |
    | & | 비트 단위로 AND 연산을 한다.
    예) num1 & num2 |
    | | | 비트 단위로 OR 연산을 한다.
    예) num1 | num2 |

### 파이썬 구현

- 7 & 5 → 이진수로 표현하면 0b111 & 0b101

```python
print(7 & 5) # 5
print(7 | 5) # 7
```

- 2진수, 16진수, 10진수 변환하여 출력하기
    - 2진수는 숫자 0과 소문자 b → 0b를 접두사로 붙여 표현한다.
    - 16진수는 숫자 0과 소문자 x → 0x를 접두사로 붙여 표현한다.
    
    ```python
    # 10진수를 2, 16진수로 변환
    print(bin(10))
    print(hex(10))
    
    # 2, 16진수를 10진수로 변환
    print(int('1011', 2))   # 2 진수
    print(int('b', 16))     # 16 진수
    ```
    

### XOR와 NOT 연산자

- ^ : XOR(엑스오어) 연산자, OR 처럼 동작 되는데 둘 다 1인 경우는 0이다.
    
    
    | 연산자 | 연산자의 기능 |
    | --- | --- |
    | ^ | 비트 단위로 XOR 연산을 한다. (같으면 0, 다르면 1)
    예) num1 ^ num2 |
- 신기한 XOR
    - 어떤 값이던 특정 수로 2회 XOR를 하면 원래 수로 돌아온다.
        - 7070 ^ 1004 = 6258
        - 6258 ^ 1004 = 7070
    - 암호화에 사용된다.
        - 친구 1과 친구 2는 서로 비밀 코드를 1004로 약속한다.
        - 가장 기본적인 암호화 기술

### 비트 연산자

- Left Shift << : 특정 수 만큼 비트를 왼쪽으로 밀어낸다.
- Right Shift >> : 특정 수 만큼 비트를 오른쪽으로 밀어낸다. (우측 비트들이 제거된다.)
    
    
    | 연산자 | 연산자의 기능 |
    | --- | --- |
    | << | 피연산자의 비트 열을 왼쪽으로 이동시킨다.
    예) num << 2   # 2회 이동 |
    | >> | 피연산자의 비트 열을 오른쪽으로 이동시킨다.
    예) num >> 2   # 2회 이동 |

### 비트 연산 응용

- 1 << n
    - $2^n$의 값을 갖는다.
    - 임베디드 분야에서 계산을 빠르게 하기 위해 사용된다. → 부분집합의 개수
- i & (1 << n)
    - i의  n번째 비트가 1인지 아닌지를 확인할 수 있다.
    - ex) 1101 & (1<<2)
    1101에서 2번 bit가 1인지 확인 가능하다. (결괏값 = 0100)
    결괏값이 0보다 크면 n번째 비트는 1임이 확정된다.
- 음수 표현 방법
    - 컴퓨터는 음수를 “2의 보수”로 관리한다.
    맨 앞자리 bit (MSB)는 음수 or 양수를 구분하는 비트이다.
        - 반전 후 + 1
    - 컴퓨터가 2의 보수를 사용하여 음수를 관리하는 이유
        - 뺄셈의 연산 속도를 올릴 수 있으며, +0과 -0을 따로 취급하지 않기 위해 사용한다.
        
        ```python
        def Bbit_print(i):
        	output = ''
        	for j in range(7, -1, -1):
        		output += '1' if i & (1 << j) else '0'
        	print(output)
        	
        for i in range(-5, 6):
        	print(f'{i} = ', end='')
        	Bbit_print(i)
        ```
        
    - 2의 보수를 취한 수를, 한번 더 2의 보수를 취하면 원래의 값으로 돌아온다.

### NOT 연산자

- (~) NOT 연산자 : 모든 비트를 반전시킨다.
- 만약 8 bit 일 때 ~(0001 1111) 이라면 값은 1110 0000이 된다.
- 파이썬에서 수행하기
    - ~4를 수행하면 -5가 출력
    - 4 = 0b0100. (MSB : 양수이므로 0)
    - NOT 연산자로 인해 뒤집으면 1011이 된다.
    - MSB는 1이 되었고 (음수), 나머지 bit는 011이다.
    - 나머지 bit에 대해 2의 보수를 취하면 100 + 1 = 101 이므로 5가 된다.
    - 따라서 -5가 된다.

## 실수

- 소수점 출력 방법
    - `{t2:.2f}` : t2 값을 소수점 둘째자리에서 반올림하여 표현
- 컴퓨터는 실수를 내부적으로 근사적으로 관리한다.
    - 이진법으로 표현 할 수 없는 형태의 실수는 정확한 값이 아니라 근사 값으로 저장되는데 이때 생기는 작은 오차가 계산 과정에서 다른 결과를 가져온다. → 부동소수점 오류
    - 비트로 표현하면 무한 반복되는 숫자끼리 더하기 때문에 오차가 발생한다!
- 실수 자료형의 유효 자릿수를 알아 두자.
    - 32 비트 실수형 유효자릿수(십진수) → 약 6 자리 (C++)
    - 64 비트 실수형 유효자릿수(십진수) → 약 15 자리 (C++, Java)
    - 파이썬에서는 내부적으로 더 많은 비트를 사용해서 훨씬 넓은 범위의 실수를 표현할 수 있다.

### 파이썬에서의 실수 표현 범위

- 파이썬에서는 다른 언어와 달리 내부적으로 더 큰 규모의 자료구조를 사용해서 훨씬 넓은 범위의 실수를 표현할 수 있다.
- 최대로 표현할 수 있는 값은 약 1.8 X 10^308이고 이 이상은 `inf`로 표현
(참고로 1억은 1 x $10^8$임)
- 최소로 표현할 수 있는 값은 약 5.0 X 10^(-324)이며, 이 이하는 0으로 표현

### 실수의 표현

- 컴퓨터는 실수를 표현하기 위해 부동 소수점(floating-point) 표기법을 사용한다.
이 표기법은 IEEE 754 이라는 컴퓨터에서 부동소수점을 표기하는 국제표준이다.
- 부동 소수점 표기 방법은 소수점의 위치를 고정시켜 표현하는 방식이다.
소수점의 위치를 왼쪽의 가장 유효한 숫자 다음으로 고정시키고 밑수의 지수승으로 표현

### 실수를 저장하기 위한 형식 (IEEE 754, 32bit - Single Precision 표기법 기준)

- 32bit 구조
    - 부호 1비트 : 0이면 양수, 1이면 음수
    - 지수부(exponent) : 부동소수점의 크기 + bias 값
    - 가수부(mantissa) : 실질적 수
- 12.375를 부동소수점으로 표기
    - 12.375를 2진수로 변환 : 12는 1100, 0.375는 0.011이므로 1100.011
    - 1100.011 = 1.100011 x 2^3
    즉, 가수는 100011이고, 지수는 3. (맨 앞 1은 생략)
- 지수 + bias : IEEE 754는 bias를 더한 결과로 표기
    - 3 + 127(bias) = 130 (2진수로는 10000010)
- 12.37를 IEEE754로 표기하는 방법
    - 부호 비트 : 0 (양수)
    - 지수 : 10000010
    - 가수 : 1000110000000000000000000
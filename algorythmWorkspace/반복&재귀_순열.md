# 반복과 재귀, 순열 / 완전 탐색

## 반복(Iteration)과 재귀(Recursion)

- 반복과 재귀는 유사한 작업을 수행할 수 있다.
- 반복은 수행하는 작업이 완료될 때 까지 계속 반복
    - 루프 (for, while 구조)
    - 반복문은 코드를 n 번 반복시킬 수 있다.
- 재귀는 주어진 문제의 해를 구하기 위해 동일하면서 더 작은 문제의 해를 이용하는 방법
    - 하나의 큰 문제를 해결할 수 있는(해결하기 쉬운) 더 작은 문제로 쪼개고 결과들을 결합한다.
    - 재귀 호출은 n 중 반복문을 만들어낼 수 있다.

### 재귀를 연습하기 전, 알아야 할 함수의 특징 1

- KFC 함수 호출할 때, int 타입 객체를 전달하면 값만 복사가 된다.
- 아래 예시에서, main 함수의 x와, KFC함수의 x는 서로 다른 객체이다.
(마치 한국 사는 KIM과, 미국 사는 KIM이 이름만 같고, 서로 다른 사람인 것 처럼
    
    ```python
    def func(x):
    	x[0] += 1
    
    x = 10
    func(x)
    print(x)   # 10
    ```
    
- 함수 호출할 때, int 타입 객체를 전달하면 값만 복사가 된다.

### 재귀를 연습하기 전, 알아야 할 함수의 특징 2

- 함수가 끝나면, Main으로 되돌아 오는 것이 아니라, 해당 함수를 호출했던 곳으로 돌아온다.

### 재귀 호출 공부의 시작은, 무한 재귀 호출을 막는 것부터 시작한다.

- 출력 결과는 0 1 1 0 이다.
- 아래 if문을 “기저 조건 (base case)” 이라고 한다.

```python
def func(x):
	# 1. 기저조건(종료조건)
	if x == 6:
		return
		
	# 2. 다음 재귀 호출 전
	print(x)
	# 3. 재귀 호출 (현재 값에 무슨 수식을 적용해서 넘겨줄까?)
	func(x + 1)  # 다음 재귀 호출에서는 현재보다 x 값이 1이 커야한다.
	# 4. 호출하고 돌아왔을 때
	print(x)
	
start = 0
func(start)
```

### [정리]

재귀호출을 이용한 코딩 기법을 익히기 위해서는, 반드시 아래 코드의 원리를 이해해야한다.

```python
def KFC(x):
	if x == 3:
		return
	for i in range(4):
		KFC(x + 1)

KFC(0)
```

## 순열 (Permutation)

### 순열이란?

- 서로 다른 N 개에서, R개를 중복없이, 순서를 고려하여 나열하는 것.
- 예시)
    - [0] [1] [2] 로 구성된 3장의 카드가 다량으로 존재한다.
    - 이 중에서 2장을 뽑아, 순열을 나열하라
    - (순열은 중복을 취급하지 않는다.)

### 중복순열이란?

- 서로 다른 N 개에서, R개를 중복을 허용하고, 순서를 고려하여 나열하는 것.
- 예시)
    - [0] [1] [2]로 구성된 3장의 카드가 다량으로 존재한다.
    - 이 중에 2장을 뽑아, 중복 순열을 나열하라
- 구현 원리
    1. 재귀 호출을 할 때 마다, 이동 경로를 흔적으로 남긴다.
    2. 가장 마지막 레벨에 도착했을 때, 이동 경로를 출력한다.
    
    <aside>
    💡
    
    먼저 path라는 전역 리스트를 준비한다.
    
    그리고 Lever 2, Branch 3으로 동작 되는 재귀 코드를 구현한다.
    
    재귀 호출을 하기 직전에 이동할 곳의 위치를 path 리스트에 기록한다.
    
    재귀 호출 되었다. 그리고 코드가 계속 진행되어, path.append(i)를 수행한다.
    
    두 번 재귀 호출 되었고, 이제 바닥에 도착했으니 이제 출력하는 코드를 수행한다.
    
    함수가 리턴 되고, 함수가 즉시 종료된다. 이후 path에 적은 마지막 기록이 삭제 되어야 한다.
    
    이어서 for문이 진행되고, 변수 i 값은 1이 된다. path 배열 마지막에 1이 삽입된다.
    
    중복 순열 소스 코드 완성 → [0, 0] ~ [2, 2] 까지 출력하는 소스 코드
    
    </aside>
    
    ```python
    path = []
    
    def KFC(x):
    	if x == 2:
    		print(path)
    		return
    	
    	for i in range(3):
    		path.append(i)
    		KFC(x + 1)
    		path.pop()
    
    KFC(0)
    ```
    

### [도전] 중복순열 [1, 1, 1] ~ [6, 6, 6] 까지 출력하는 코드를 재귀 호출로 구현

```python
path = []  # 경로를 기록할 리스트
used = [0] * 7  # 1~6 숫자의 사용 여부를 기록할 리스트

# 0부터 시작, 3개를 뽑은 경우 종료
def recur(level):
    # 기저 조건
    if level == 3:
        print(*path)
        return

    # 2. 후보군을 반복하면서
    for i in range(1, 7):
        # i가 이미 뽑혔다면, continue 해라
        # 아래 코드의 단점: "in" = 0(len(path))
        # 시간 초과 위험도가 높다.
        # if i in path:
        #     continue

        # i가 이미 뽑혔다면, continue 해라
        if used[i] == 1:
            continue

        # 2.1 재귀 호출 전 - 경로 기록 + 사용 기록
        used[i] = 1
        path.append(i)
        # 2.2 다음 재귀 호출 (파라미터 전달)
        recur(level + 1)
        # 2.3 돌아왔을 때 = 사용했던 경로 삭제
        path.pop()
        used[i] = 0

recur(0)  # 호출 : 시작점을 같이 전달해주는 경우가 많다.
```

### 중복을 취급하지 않는 “순열” 구현 방법

1. 중복 순열 코드를 작성한다.
2. 중복을 제거하는 코드를 추가하면 순열 코드가 된다.

### 중복을 제거하는 원리

- 전역 리스트를 사용하면 이미 선택했던 숫자인지 아닌지 구분할 수 있다.
- 이를 used 배열 또는 visited 배열 이라고 한다. (DFS, BFS에 사용되는 것과 같다)

## 완전 탐색

### 완전 탐색 (=Brute-Force, 부르트 포스 알고리즘)

- 모든 가능한 경우를 모두 시도를 해보아, 정답을 찾아내는 알고리즘

### 예시

- 자전거 열쇠 비밀번호 맞추기
    - 만약 1 1 1 1 ~ 9 9 9 9 네 자리 숫자를 맞춰야 한다면?
    솔루션 → 4중 for문으로 모두 시도해본다.
    - 만약 1 ~ 9 까지 이뤄진, N 자리의 숫자를 맞춰야 한다면?
    솔루션 → 순열 코드(재귀 호출)로 구현하여, 모두 시도해본다.

### 문제 1. 주사위 눈금의 합

3개의 주사위를 던져 나올 수 있는 중복 순열에 대해, 합이 10 이하가 나오는 경우는 총 몇 가지 인가?

```python
path = []

# 주사위 몇 개 던졌는지, 주사위의 합이 몇인지?
def recur(level, total):
	# 가지치기 : 이미 10을 넘는 경우의 수는 계산할 필요가 없다!
	if total > 10:
		return

	# 기저조건 : 3개를 던졌을 때 종료
	if level == 3:
		# 10 이하인가?
		if total <= 10:
			print(path)
		return
	
	# 후보군 탐색
	for i in range(1, 7):
		# i의 의미 : 주사위 숫자
		path.append(i)
		recur(level + 1, tatal + i)  # 주사위 결과를 더하여 전달
		path.pop()

recur(0, 0)
```